{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Welcome to the Istio 0 to 60 workshop!</p> <p>On this site you will find the hands-on labs for the workshop.</p> <p>In the first lab, we walk you through accessing and configuring your lab environment.</p> <p>Let's begin.</p>"},{"location":"circuit-breakers/","title":"Circuit breakers","text":"<p>This lab demonstrate how to configure circuit breaking both with and without outlier detection in Istio.</p>"},{"location":"circuit-breakers/#prerequisites-and-setup","title":"Prerequisites and setup","text":"<ul> <li>Kubernetes with Istio and other tools (Prometheus, Zipkin, Grafana) installed</li> <li><code>web-frontend</code> and <code>customers</code> workloads already deployed and running.</li> </ul>"},{"location":"circuit-breakers/#revise-the-istio-installation-configuration","title":"Revise the Istio installation configuration","text":"<p>Modify the installation of Istio to use the demo profile which enables high levels of tracing, which is convenient for this lab.</p> <pre><code>istioctl install --set profile=demo\n</code></pre>"},{"location":"circuit-breakers/#install-fortio","title":"Install Fortio","text":"<p>Let us try and generate some load to the <code>web-frontend</code> workload and see the distribution of responses.</p> <p>We'll use Fortio to generate load on the <code>web-frontend</code> service.</p> <ol> <li> <p>Deploy Fortio</p> fortio.yaml<pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  name: fortio\n  labels:\n    app: fortio\n    service: fortio\nspec:\n  ports:\n  - port: 8080\n    name: http\n  selector:\n    app: fortio\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: fortio\nspec:\n  selector:\n    matchLabels:\n      app: fortio\n  template:\n    metadata:\n      annotations:\n        # This annotation causes Envoy to serve cluster.outbound statistics via 15000/stats\n        # in addition to the stats normally served by Istio.\n        proxy.istio.io/config: |-\n          proxyStatsMatcher:\n            inclusionPrefixes:\n            - \"cluster.outbound\"\n            - \"cluster_manager\"\n            - \"listener_manager\"\n            - \"server\"\n            - \"cluster.xds-grpc\"\n      labels:\n        app: fortio\n    spec:\n      containers:\n      - name: fortio\n        image: fortio/fortio:latest\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8080\n          name: http-fortio\n        - containerPort: 8079\n          name: grpc-ping\n</code></pre> <p>Above, notice the annotation, which configures the inclusion of additional Envoy metrics (aka statistics) including circuit breaking.</p> <p>Save the above file to <code>fortio.yaml</code> and deploy it:</p> <pre><code>kubectl apply -f fortio.yaml\n</code></pre> </li> <li> <p>Make a single request to make sure everything is working:</p> <pre><code>kubectl exec deploy/fortio -c fortio -- fortio curl web-frontend\n</code></pre> <p>The above command should result in an HTTP 200 \"OK\" response from the <code>web-frontend</code> app.</p> </li> <li> <p>With fortio, we can generate a load of 50 requests with two concurrent connections like this:</p> <pre><code>kubectl exec deploy/fortio -c fortio -- \\\n  fortio load -c 2 -qps 0 -n 50 -quiet web-frontend\n</code></pre> <p>All 50 requests should succeed.  That is the meaning of <code>Code 200 : 50</code> in the output.</p> </li> </ol> <p>Info</p> <p>Fortio also has a GUI, to access it:</p> <ol> <li> <p>Port-forward the deployment's port</p> <pre><code>kubectl port-forward deploy/fortio 8080\n</code></pre> </li> <li> <p>In a browser, visit http://localhost:8080/fortio</p> </li> </ol>"},{"location":"circuit-breakers/#circuit-breaker-connection-pool-settings","title":"Circuit breaker - connection pool settings","text":"<p>Study the following DestionationRule:</p> cb-web-frontend.yaml<pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: web-frontend\nspec:\n  host: web-frontend.default.svc.cluster.local\n  trafficPolicy:\n    connectionPool:\n      http:\n        http1MaxPendingRequests: 1 # (1)\n        http2MaxRequests: 1 # (2)\n        maxRequestsPerConnection: 1 # (3)\n</code></pre> <ol> <li>The maximum number of pending HTTP requests to a destination.</li> <li>The maximum number of concurrent requests to a destination.</li> <li>The maximum number of requests per connection.</li> </ol> <p>It configures the connection pool for <code>web-frontend</code> with very low thresholds, to easily trigger the circuit breaker.</p> <p>Save the above YAML to <code>cb-web-frontend.yaml</code> and apply the changes:</p> <pre><code>kubectl apply -f cb-web-frontend.yaml\n</code></pre> <p>Since all values are set to 1, we won't trigger the circuit breaker if we send the request using one connection and one request per second.</p> <p>If we increase the number of connections and send more requests (i.e. 2 workers sending requests concurrently, and sending 50 requests), we'll start getting errors.</p> <p>The errors happen because the <code>http2MaxRequests</code> is set to 1 and we have more than 1 concurrent request being sent. Additionally, we're exceeding the <code>maxRequestsPerConnection</code> limit.</p> <pre><code>kubectl exec deploy/fortio -c fortio -- \\\n  fortio load -c 2 -qps 0 -n 50 -quiet web-frontend\n</code></pre> <pre><code>...\nCode 200 : 24 (48.0 %)\nCode 503 : 26 (52.0 %)\n</code></pre> <p>Tip</p> <p>To reset the metric counters, run:</p> <pre><code>kubectl exec deploy/fortio -c istio-proxy -- curl -sX POST localhost:15000/reset_counters\n</code></pre>"},{"location":"circuit-breakers/#the-x-envoy-overloaded-header","title":"The <code>x-envoy-overloaded</code> header","text":"<p>When a request is dropped due to circuit breaking, the response will contain a response header <code>x-envoy-overloaded</code> with value \"true\".</p> <p>One way to see this header is to run a fortio load with two concurrent connections in one terminal for a couple of minutes:</p> <pre><code>kubectl exec deploy/fortio -c fortio -- \\\n  fortio load -c 2 -qps 0 -t 2m --allow-initial-errors -quiet http://web-frontend\n</code></pre> <p>In a separate terminal, invoke a single request:</p> <pre><code>kubectl exec deploy/fortio -c fortio -- fortio curl http://web-frontend\n</code></pre> <p>Here is an example response to a dropped request:</p> <pre><code>&gt; HTTP/1.1 503 Service Unavailable\n&gt; x-envoy-overloaded: true\n&gt; content-length: 81\n&gt; content-type: text/plain\n&gt; date: Thu, 10 Aug 2023 18:25:37 GMT\n&gt; server: envoy\n&gt;\n&gt; upstream connect error or disconnect/reset before headers. reset reason: overflowcommand terminated with exit code 1\n</code></pre> <p>Then press Ctrl+C to interrupt the load generation.</p>"},{"location":"circuit-breakers/#observe-failures-in-zipkin","title":"Observe failures in Zipkin","text":"<p>Open the Zipkin dashboard:</p> <pre><code>istioctl dash zipkin\n</code></pre> <p>In the Zipkin UI, list failing traces by clicking the \"+\" button in the search field and specifying the query: <code>tagQuery=error</code>.  Then click the Run Query button.</p> <p>Pick a failing trace to view the details.</p> <p>The requests are failing because the circuit breaker is tripped.  Response flags are set to <code>UO</code> (Upstream Overflow) and the status code is 503 (service unavailable).</p>"},{"location":"circuit-breakers/#prometheus-metrics","title":"Prometheus metrics","text":"<p>Another option is looking at the Prometheus metrics directly.</p> <p>Open the Prometheus dashboard:</p> <pre><code>istioctl dash prometheus\n</code></pre> <p>Apply the following PromQL query:</p> <pre><code>envoy_cluster_upstream_rq_pending_overflow{app=\"fortio\", cluster_name=\"outbound|80||web-frontend.default.svc.cluster.local\"}\n</code></pre> <p>The query shows the metrics for requests originating from the <code>fortio</code> app and going to the <code>web-frontend</code> service.</p> <p>The <code>upstream_rq_pending_overflow</code> and other metrics are described in the Envoy documentation.</p> <p>Noteworthy are circuit-breaking specific metrics showing the state of various circuit breakers.  For example <code>rq_open</code> indicates whether the \"requests\" circuit breaker is open, and its companion <code>remaining_rq</code> indicates how many requests remain to trip the corresponding circuit breaker.</p> <p>We can also look at the metrics directly from the <code>istio-proxy</code> container in the Fortio Pod:</p> <pre><code>kubectl exec deploy/fortio -c istio-proxy -- \\\n  pilot-agent request GET stats | grep web-frontend | grep pending\n</code></pre> <pre><code>cluster.outbound|80||web-frontend.default.svc.cluster.local.circuit_breakers.default.remaining_pending: 1\ncluster.outbound|80||web-frontend.default.svc.cluster.local.circuit_breakers.default.rq_pending_open: 0\ncluster.outbound|80||web-frontend.default.svc.cluster.local.circuit_breakers.high.rq_pending_open: 0\ncluster.outbound|80||web-frontend.default.svc.cluster.local.upstream_rq_pending_active: 0\ncluster.outbound|80||web-frontend.default.svc.cluster.local.upstream_rq_pending_failure_eject: 0\ncluster.outbound|80||web-frontend.default.svc.cluster.local.upstream_rq_pending_overflow: 26\ncluster.outbound|80||web-frontend.default.svc.cluster.local.upstream_rq_pending_total: 24\n</code></pre> <p>Info</p> <p>Yet another convenient way to look at the stats emitted by an Envoy sidecar is via the Envoy dashboard:</p> <pre><code>istioctl dashboard envoy deploy/fortio\n</code></pre> <p>In the web ui, click on the \"stats\" endpoint, and filter by target outbound cluster \"web-frontend\".</p>"},{"location":"circuit-breakers/#resolving-the-errors","title":"Resolving the errors","text":"<p>To resolve these errors, we can adjust the circuit breaker settings.</p> <p>Increase the maximum number of concurrent requests to 2 (<code>http2MaxRequests</code>), as shown below:</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: web-frontend\nspec:\n  host: web-frontend.default.svc.cluster.local\n  trafficPolicy:\n    connectionPool:\n      http:\n        http1MaxPendingRequests: 1\n        http2MaxRequests: 2\n        maxRequestsPerConnection: 1\n</code></pre> <p>Save the above YAML to <code>cb-web-frontend.yaml</code> and apply the changes:</p> <pre><code>kubectl apply -f cb-web-frontend.yaml\n</code></pre> <p>If we re-run Fortio with the same parameters, we'll notice less failures this time:</p> <pre><code>kubectl exec deploy/fortio -c fortio -- \\\n  fortio load -c 2 -qps 0 -n 50 -quiet web-frontend\n</code></pre> <pre><code>...\nCode 200 : 39 (78.0 %)\nCode 503 : 11 (22.0 %)\n</code></pre> <p>Since we're sending more than 1 request per connection, we can increase the <code>maxRequestsPerConnection</code> to 2:</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: web-frontend\nspec:\n  host: web-frontend.default.svc.cluster.local\n  trafficPolicy:\n    connectionPool:\n      http:\n        http1MaxPendingRequests: 1\n        http2MaxRequests: 2\n        maxRequestsPerConnection: 2\n</code></pre> <p>Save the above YAML to <code>cb-web-frontend.yaml</code> and apply the changes:</p> <pre><code>kubectl apply -f cb-web-frontend.yaml\n</code></pre> <p>If we re-run Fortio this time, we'll get zero or close to zero HTTP 503 responses. Even if we increase the number of requests per second, we should only get a small number of 503 responses. To get rid of the remaining failing requests, we can increase the <code>http1MaxPendingRequests</code> to 2:</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: web-frontend\nspec:\n  host: web-frontend.default.svc.cluster.local\n  trafficPolicy:\n    connectionPool:\n      http:\n        http1MaxPendingRequests: 2\n        http2MaxRequests: 2\n        maxRequestsPerConnection: 2\n</code></pre> <p>With these settings (assuming 2 concurrent connections), we can easily handle a higher number of requests.</p> <p>To be clear, the numbers we used in settings are just examples and are not realistic - we set them intentionally low to make the circuit breaker easier to trip.</p> <p>Before continuing, delete the DestinationRule:</p> <pre><code>kubectl delete destinationrule web-frontend\n</code></pre> <p>Reset the metric counters:</p> <pre><code>kubectl exec deploy/fortio -c istio-proxy -- \\\n  curl -X POST localhost:15000/reset_counters\n</code></pre>"},{"location":"circuit-breakers/#outlier-detection","title":"Outlier detection","text":"<p>The circuit breaker is great when we want to protect the services from a sudden burst of requests. However, how can we protect the services in case of failures?</p> <p>For example, if we have a service that is still failing after multiple requests, it doesn't make sense to send even more requests to it. Instead, we can remove the instance of the failing service from the load balancing pool for a certain period of time. That way, we know that the requests will go to other instances of the service. After a pre-defined period of time, we can bring the failing service back into the load balancing pool.</p> <p>This process is called outlier detection. Just like in the connection pool settings, we can configure outlier detection in the DestinationRule.</p> <p>To see the outlier detection in action we need a service that is failing. We'll create a <code>web-frontend-failing</code> deployment and configure it to return HTTP 503 responses:</p> Click for web-frontend-failing.yaml web-frontend-failing.yaml<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-frontend-failing\n  labels:\n    app: web-frontend\nspec:\n  replicas: 4\n  selector:\n    matchLabels:\n      app: web-frontend\n  template:\n    metadata:\n      labels:\n        app: web-frontend\n        version: v1\n    spec:\n      serviceAccountName: web-frontend\n      containers:\n        - image: gcr.io/tetratelabs/web-frontend:1.0.0\n          imagePullPolicy: Always\n          name: web\n          ports:\n            - containerPort: 8080\n          env:\n            - name: CUSTOMER_SERVICE_URL\n              value: 'http://customers.default.svc.cluster.local'\n            - name: ERROR_RATE\n              value: '100'\n            - name: ERROR_STATUS_CODE\n              value: '500'\n</code></pre> <p>Save the above YAML to <code>web-frontend-failing.yaml</code> and apply it to the cluster:</p> <pre><code>kubectl apply -f web-frontend-failing.yaml\n</code></pre> <p>If we run Fortio we'll see that majority (roughly, 80%) of the requests will be failing. That's because the <code>web-frontend-failing</code> deployment has more replicas than the \"good\" deployment.</p> <pre><code>kubectl exec deploy/fortio -c fortio -- \\\n  fortio load -c 2 -qps 0 -n 50 -quiet web-frontend\n</code></pre> <pre><code>...\nCode 200 : 9 (18.0 %)\nCode 500 : 41 (82.0 %)\n</code></pre> <p>Let's look at an example of outlier detection configuration:</p> outlier-web-frontend.yaml<pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: web-frontend\nspec:\n  host: web-frontend.default.svc.cluster.local\n  trafficPolicy:\n    outlierDetection:\n      consecutive5xxErrors: 1 # (1)\n      interval: 5s # (2)\n      baseEjectionTime: 60s # (3)\n      maxEjectionPercent: 100 # (4)\n</code></pre> <ol> <li>Number of 5xx errors in a row that will trigger the outlier detection. </li> <li>The interval at which the hosts are checked whether they need to be ejected.</li> <li>The duration of time an outlier is ejected from the load balancing pool. If the same host is ejected multiple times, the ejection time increases by multiplying the base ejection time by the number of times the host is ejected.</li> <li>The maximum percentage of hosts that can be ejected.</li> </ol> <p>Save the YAML to <code>outlier-web-frontend.yaml</code> and apply it:</p> <pre><code>kubectl apply -f outlier-web-frontend.yaml\n</code></pre> <p>If we repeat the test, we might get a similar distribution of responses the first time.  However, if we repeat the command (once the outliers were ejected), we'll get a much better distribution:</p> <pre><code>kubectl exec deploy/fortio -c fortio -- \\\n  fortio load -c 2 -qps 0 -n 50 -quiet web-frontend\n</code></pre> <pre><code>...\nCode 200 : 50 (100.0 %)\n</code></pre> <p>The reason for more HTTP 200 responses is because as soon as the failing hosts were ejected (failing Pods from the <code>web-frontend-failing</code> deployment), the requests were sent to the other host that doesn't fail. If we waited until after the 60 second <code>baseEjectionTime</code> expired, the failing hosts would be brought back into the load balancing pool and we'd get a similar distribution of responses as before (majority of them failing).</p> <p>We can also look at the metrics from the outlier detection in the same way we did for the circuit breakers:</p> <pre><code>kubectl exec deploy/fortio -c istio-proxy -- \\\n  pilot-agent request GET stats | grep web-frontend | grep ejections_total\n</code></pre> <p>Produces output similar to this:</p> <pre><code>cluster.outbound|80||web-frontend.default.svc.cluster.local.outlier_detection.ejections_total: 4\n</code></pre> <p>Note</p> <p>Other metrics that we can look at are <code>ejections_consecutive_5xx</code>, <code>ejections_enforced_total</code> or any other metric with <code>outlier_detection</code> in its name. The full list of metric names and their descriptions can be found in the Envoy documentation.</p>"},{"location":"circuit-breakers/#cleanup","title":"Cleanup","text":"<p>To clean up resources created in this lab, run:</p> <pre><code>kubectl delete destinationrule web-frontend\nkubectl delete -f web-frontend-failing.yaml\nkubectl delete -f fortio.yaml\n</code></pre>"},{"location":"dashboards/","title":"Observability","text":"<p>This lab explores one of the main strengths of Istio: observability.</p> <p>The services in our mesh are automatically made observable, without adding any burden on devops teams.</p>"},{"location":"dashboards/#deploy-the-addons","title":"Deploy the Addons","text":"<p>The Istio distribution provides addons for a number of systems that together provide observability for the service mesh:</p> <ul> <li>Zipkin or Jaeger for distributed tracing</li> <li>Prometheus for metrics collection</li> <li>Grafana provides dashboards for monitoring, using Prometheus as the data source</li> <li>Kiali allows us to visualize the mesh</li> </ul> <p>These addons are located in the <code>samples/addons/</code> folder of the distribution.</p> <ol> <li> <p>Navigate to the addons directory</p> <pre><code>cd ~/istio-1.21.0/samples/addons\n</code></pre> </li> <li> <p>Deploy each addon:</p> <pre><code>kubectl apply -f prometheus.yaml\n</code></pre> <pre><code>kubectl apply -f grafana.yaml\n</code></pre> <pre><code>kubectl apply -f extras/zipkin.yaml\n</code></pre> <pre><code>kubectl apply -f kiali.yaml\n</code></pre> </li> <li> <p>Verify that the <code>istio-system</code> namespace is now running additional workloads for each of the addons.</p> <pre><code>kubectl get pod -n istio-system\n</code></pre> </li> </ol> <p>The <code>istioctl</code> CLI provides convenience commands for accessing the web UIs for each dashboard.</p> <p>Take a moment to review the help information for the <code>istioctl dashboard</code> command:</p> <pre><code>istioctl dashboard --help\n</code></pre>"},{"location":"dashboards/#generate-a-load","title":"Generate a load","text":"<p>In order to have something to observe, we need to generate a load on our system.</p> <p>Use a simple bash <code>while</code> loop to make repeated <code>curl</code> requests to the app:</p> <pre><code>while true; do curl -I http://$GATEWAY_IP; sleep 0.5; done\n</code></pre> <p>The curl requests will be running in foreground. It may be simplest to obtain a new shell prompt by opening a second, separate terminal.</p>"},{"location":"dashboards/#kiali","title":"Kiali","text":"<p>Launch the Kiali dashboard:</p> <pre><code>istioctl dashboard kiali\n</code></pre> <p>Warning</p> <p>If the dashboard page fails to open, just click on the hyperlink in the console output.</p> <p>Note</p> <p>The <code>istioctl dashboard</code> command also blocks. Leave it running until you're finished using the dashboard, at which time  press Ctrl+C to interrupt the process and get back to the terminal prompt.</p> <p>The Kiali dashboard displays.</p> <p>Customize the view as follows:</p> <ol> <li>Select the Graph section from the sidebar.</li> <li>Under Select Namespaces (at the top of the page), select the <code>default</code> namespace, the location where the application's pods are running.</li> <li>From the third \"pulldown\" menu, select App graph.</li> <li>From the Display \"pulldown\", toggle on Traffic Animation and Security.</li> <li>From the footer, toggle the legend so that it is visible.  Take a moment to familiarize yourself with the legend.</li> </ol> <p>Observe the visualization and note the following:</p> <ul> <li>We can see traffic coming in through the ingress gateway to the <code>web-frontend</code>, and the subsequent calls from the <code>web-frontend</code> to the <code>customers</code> service.</li> <li>The lines connecting the services are green, indicating healthy requests.</li> <li>The small lock icon on each edge in the graph indicates that the traffic is secured with mutual TLS.</li> </ul> <p>Such visualizations are helpful with understanding the flow of requests in the mesh, and with diagnosis.</p> <p>Feel free to spend more time exploring Kiali.</p> <p>We will revisit Kiali in a later lab to visualize traffic shifting such as when performing a blue-green or canary deployment.</p>"},{"location":"dashboards/#kiali-cleanup","title":"Kiali Cleanup","text":"<p>Close the Kiali dashboard.  Interrupt the <code>istioctl dashboard kiali</code> command by pressing Ctrl+C.</p>"},{"location":"dashboards/#zipkin","title":"Zipkin","text":"<p>Launch the Zipkin dashboard:</p> <pre><code>istioctl dashboard zipkin\n</code></pre> <p>The Zipkin dashboard displays.</p> <ul> <li>Click on the red '+' button and select serviceName.</li> <li>Select the service named <code>web-frontend.default</code> and click on the Run Query button (lightblue) on the right.</li> </ul> <p>Trace Sampling</p> <p>When you installed Istio at the start of this workshop, the default configuration uses the default profile, which sets trace sampling to 1% of requests.</p> <p>If you wish to increase the trace sampling percentage to capture more distributed traces, you can upgrade the Istio installation with the following command:</p> <pre><code>istioctl install --set values.pilot.traceSampling=100\n</code></pre> <p>A number of query results will display.  Each row is expandable and will display more detail in terms of the services participating in that particular trace.</p> <ul> <li>Click the Show button to the right of one of the traces having four (4) spans.</li> </ul> <p>The resulting view shows spans that are part of the trace, and more importantly how much time was spent within each span.  Such information can help diagnose slow requests and pin-point where the latency lies.</p> <p>Distributed tracing also helps us make sense of the flow of requests in a microservice architecture.</p>"},{"location":"dashboards/#zipkin-cleanup","title":"Zipkin Cleanup","text":"<p>Close the Zipkin dashboard.  Interrupt the <code>istioctl dashboard zipkin</code> command with Ctrl+C.</p>"},{"location":"dashboards/#prometheus","title":"Prometheus","text":"<p>Prometheus works by periodically calling a metrics endpoint against each running service (this endpoint is termed the \"scrape\" endpoint).  Developers normally have to instrument their applications to expose such an endpoint and return metrics information in the format the Prometheus expects.</p> <p>With Istio, this is done automatically by the Envoy sidecar.</p>"},{"location":"dashboards/#observe-how-envoy-exposes-a-prometheus-scrape-endpoint","title":"Observe how Envoy exposes a Prometheus scrape endpoint","text":"<ol> <li> <p>Run the following command:</p> <pre><code>kubectl exec svc/customers -- curl -s localhost:15020/stats/prometheus \\\n  | grep istio_requests\n</code></pre> <p>Why port 15020?</p> <p>See Ports used by Istio sidecar proxy.</p> <p>The list of metrics returned by the endpoint is rather lengthy, so we just peek at \"istio_requests\" metric.  The full response contains many more metrics.</p> </li> </ol>"},{"location":"dashboards/#access-the-dashboard","title":"Access the dashboard","text":"<ol> <li> <p>Start the prometheus dashboard</p> <pre><code>istioctl dashboard prometheus\n</code></pre> </li> <li> <p>In the search field enter the metric named <code>istio_requests_total</code>, and click the Execute button (on the right).</p> </li> <li> <p>Select the tab named Graph to obtain a graphical representation of this metric over time.</p> <p>Note that you are looking at requests across the entire mesh, i.e. this includes both requests to <code>web-frontend</code> and to <code>customers</code>.</p> </li> <li> <p>As an example of Prometheus' dimensional metrics capability, we can ask for total requests having a response code of 200:</p> <pre><code>istio_requests_total{response_code=\"200\"}\n</code></pre> </li> <li> <p>With respect to requests, it's more interesting to look at the rate of incoming requests over a time window.  Try:</p> <pre><code>rate(istio_requests_total[5m])\n</code></pre> </li> </ol> <p>There's much more to the Prometheus query language (this may be a good place to start).</p> <p>Grafana consumes these metrics to produce graphs on our behalf.</p> <p>Close the Prometheus dashboard and terminate the corresponding <code>istioctl dashboard</code> command.</p>"},{"location":"dashboards/#grafana","title":"Grafana","text":"<ol> <li> <p>Launch the Grafana dashboard</p> <pre><code>istioctl dashboard grafana\n</code></pre> </li> <li> <p>From the sidebar, select Dashboards</p> </li> <li>Click on the folder named Istio to reveal pre-designed Istio-specific Grafana dashboards</li> <li>Explore the Istio Mesh Dashboard.  Note the Global Request Volume and Global Success Rate.</li> <li>Explore the Istio Service Dashboard.  First select the service <code>web-frontend</code> and inspect its metrics, then switch to the <code>customers</code> service and review its dashboard.</li> <li>Explore the Istio Workload Dashboard.  Select the <code>web-frontend</code> workload.  Look at Outbound Services and note the outbound requests to the customers service.  Select the <code>customers</code> workload and note that it makes no Outbound Services calls.</li> </ol> <p>Feel free to further explore these dashboards.</p>"},{"location":"dashboards/#cleanup","title":"Cleanup","text":"<ol> <li>Terminate the <code>istioctl dashboard</code> command (Ctrl+C)</li> <li>Likewise, terminate the bash while loop.</li> </ol>"},{"location":"dashboards/#next","title":"Next","text":"<p>We turn our attention next to security features of a service mesh.</p>"},{"location":"discovery/","title":"Service discovery and load balancing","text":"<p>This lab is a standalone exploration of service discovery and load balancing in Istio.</p>"},{"location":"discovery/#clusters-and-endpoints","title":"Clusters and endpoints","text":"<p>The <code>istioctl</code> CLI's diagnostic command <code>proxy-status</code> provides a simple way to list all proxies that Istio knows about.</p> <p>Run and study the output of the <code>proxy-status</code> command:</p> <pre><code>istioctl proxy-status\n</code></pre> <p>Since We have not yet deployed any workloads, the output should be rather anemic, citing the lone ingress gateway that was deployed when we installed Istio in the previous lab.</p>"},{"location":"discovery/#enable-automatic-sidecar-injection","title":"Enable automatic sidecar injection","text":"<p>There are two options for sidecar injection: automatic and manual.</p> <p>In this lab we will use automatic injection, which involves labeling the namespace where the pods are to reside.</p> <ol> <li> <p>Label the default namespace</p> <pre><code>kubectl label namespace default istio-injection=enabled\n</code></pre> </li> <li> <p>Verify that the label has been applied:</p> <pre><code>kubectl get ns -Listio-injection\n</code></pre> </li> </ol>"},{"location":"discovery/#deploy-the-helloworld-sample","title":"Deploy the <code>helloworld</code> sample","text":"<p>The Istio distribution comes with a sample application \"helloworld\".</p> <pre><code>cd ~/istio-1.21.0\n</code></pre> <p>Deploy <code>helloworld</code> to the default namespace.</p> <pre><code>kubectl apply -f samples/helloworld/helloworld.yaml\n</code></pre> <p>Check the output of <code>proxy-status</code> again:</p> <pre><code>istioctl proxy-status\n</code></pre> <p>Confirm that the two <code>helloworld</code> workloads are listed and marked as \"SYNCED\".</p> <p>While here, let us also deploy the sample app called <code>sleep</code>, that will serve the purpose of a client from which we might call the <code>helloworld</code> app:</p> <pre><code>kubectl apply -f samples/sleep/sleep.yaml\n</code></pre>"},{"location":"discovery/#the-service-registry","title":"The service registry","text":"<p>Istio maintains an internal service registry which can be observed through a debug endpoint <code>/debug/registryz</code> exposed by <code>istiod</code>:</p> <p><code>curl</code> the registry endpoint:</p> <pre><code>kubectl exec -n istio-system deploy/istiod -- \\\n  curl -s localhost:15014/debug/registryz\n</code></pre> <p>The output can be prettified, and filtered (to highlight the list of host names in the registry) with a tool such as <code>jq</code>.</p> <pre><code>kubectl exec -n istio-system deploy/istiod -- \\\n  curl -s localhost:15014/debug/registryz | jq .[].hostname\n</code></pre> <p>Confirm that the <code>helloworld</code> service is listed in the output.</p>"},{"location":"discovery/#the-sidecar-configuration","title":"The sidecar configuration","text":"<p>Review the deployments in the <code>default</code> namespace:</p> <pre><code>kubectl get deploy\n</code></pre> <p>The <code>istioctl</code> CLI's diagnostic command <code>proxy-config</code> will help us inspect the configuration of proxies.</p> <p>Envoy's term for a service is \"cluster\".</p> <p>Confirm that <code>sleep</code> knows about other services (<code>helloworld</code>, <code>customers</code>, etc..):</p> <pre><code>istioctl proxy-config clusters deploy/sleep\n</code></pre> <p>List the endpoints backing each \"cluster\":</p> <pre><code>istioctl proxy-config endpoints deploy/sleep\n</code></pre> <p>Zero in on the endpoints for the <code>helloworld</code> service:</p> <pre><code>istioctl proxy-config endpoints deploy/sleep \\\n  --cluster \"outbound|5000||helloworld.default.svc.cluster.local\"\n</code></pre> <p>We learn that Istio has communicated to the <code>sleep</code> workload information about both <code>helloworld</code> endpoints.</p>"},{"location":"discovery/#load-balancing","title":"Load balancing","text":"<p>The <code>sleep</code> pod's container image has <code>curl</code> pre-installed.</p> <p>Make repeated calls to the <code>helloworld</code> service from the <code>sleep</code> pod:</p> <pre><code>for i in {1..3}; do\n  kubectl exec deploy/sleep -- curl -s helloworld:5000/hello\ndone\n</code></pre> <p>Some responses will be from <code>helloworld-v1</code> while others from <code>helloworld-v2</code>, an indication that Envoy is load-balancing requests between these two endpoints.</p> <p>Envoy does not use the ClusterIP service.  It performs client-side load-balancing using the endpoints you resolved above.</p> <p>We can examine the <code>helloworld</code> \"cluster\" definition in a sample client to see what load balancing policy is in effect:</p> <pre><code>istioctl proxy-config cluster deploy/sleep \\\n  --fqdn helloworld.default.svc.cluster.local -o yaml | grep lbPolicy\n</code></pre> <p>To influence the load balancing algorithm that Envoy uses when calling <code>helloworld</code>, we can define a traffic policy, like so:</p> helloworld-lb.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: helloworld-trafficpolicy\nspec:\n  host: helloworld.default.svc.cluster.local\n  trafficPolicy:\n    loadBalancer:\n      simple: RANDOM\n</code></pre> <p>Apply the above traffic policy to the cluster:</p> <pre><code>kubectl apply -f helloworld-lb.yaml\n</code></pre> <p>Examine the updated load-balancer policy:</p> <pre><code>istioctl proxy-config cluster deploy/sleep \\\n  --fqdn helloworld.default.svc.cluster.local -o yaml | grep lbPolicy\n</code></pre> <p>Confirm that it now reads \"RANDOM\".</p> <p>For more insight into the merits of the different load balancing options, read the blog entry Examining Load Balancing Algorithms with Envoy from the Envoy Proxy blog.</p>"},{"location":"discovery/#traffic-distribution","title":"Traffic distribution","text":"<p>We can go a step further and control how much traffic to send to version v1 and how much to v2.</p> <p>First, define the two subsets, v1 and v2:</p> helloworld-dr.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: helloworld-trafficpolicy\nspec:\n  host: helloworld.default.svc.cluster.local\n  trafficPolicy:\n    loadBalancer:\n      simple: LEAST_REQUEST\n  subsets:\n  - name: v1\n    labels:\n      version: v1\n  - name: v2\n    labels:\n      version: v2\n</code></pre> <p>Apply the updated destination rule to the cluster:</p> <pre><code>kubectl apply -f helloworld-dr.yaml\n</code></pre> <p>If we now inspect the list of clusters, note that there's one for each subset:</p> <pre><code>istioctl proxy-config cluster deploy/sleep \\\n  --fqdn helloworld.default.svc.cluster.local\n</code></pre> <p>With the subsets defined, we turn our attention to the routing specification.  We use a VirtualService, in this case to direct 25% of traffic to v1 and 75% to v2:</p> helloworld-vs.yaml<pre><code>---\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: hello-routing\nspec:\n  hosts:\n  - helloworld.default.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: helloworld.default.svc.cluster.local\n        subset: v1\n      weight: 25\n    - destination:\n        host: helloworld.default.svc.cluster.local\n        subset: v2\n      weight: 75\n</code></pre> <p>Apply the VirtualService to the cluster:</p> <pre><code>kubectl apply -f helloworld-vs.yaml\n</code></pre> <p>Finally, we can inspect the routing rules applied to an Envoy client with our <code>proxy-config</code> diagnostic command:</p> <pre><code>istioctl proxy-config routes deploy/sleep --name 5000 -o yaml\n</code></pre> <p>Note the <code>weightedClusters</code> section in the routes output.</p> <p>The <code>istioctl</code> CLI provides a convenient command to inspect the configuration of a service:</p> <pre><code>istioctl x describe svc helloworld\n</code></pre> <p>I think you'll agree the output of the <code>istioctl x describe</code> command is a little easier to parse in comparison.</p>"},{"location":"environment/","title":"Lab environment","text":""},{"location":"environment/#options","title":"Options","text":"BYO K8SGCPKillercodaLocal <p>If you brought your own Kubernetes cluster:</p> <ul> <li> <p>Istio version 1.21.0 officially supports Kubernetes versions 1.26 - 1.29.  Feel free to consult the Istio support status of Istio releases page for more information.</p> </li> <li> <p>We recommend a 3-worker node cluster of machine type \"e2-standard-2\" or similar, though a smaller cluster will likely work just fine.</p> </li> </ul> <p>If you have your own public cloud account:</p> <ul> <li> <p>On GCP, the following command should provision a GKE cluster of adequate size for the workshop:</p> <pre><code>gcloud container clusters create my-istio-cluster \\\n  --cluster-version latest \\\n  --machine-type \"e2-standard-2\" \\\n  --num-nodes \"3\" \\\n  --network \"default\"\n</code></pre> </li> <li> <p>Feel free to provision a K8S cluster on any infrastructure of your choosing.</p> </li> </ul> <p>Be sure to configure your <code>kubeconfig</code> file to point to your cluster.</p> <p>If you received Google credentials from the workshop instructors:</p> <ul> <li>A Kubernetes cluster has already been provisioned for you.</li> <li>Your instructor will demonstrate the process of accessing and configuring your environment, described below.</li> <li>The instructions below explain in detail how to access your account, select your project, and launch the cloud shell.</li> </ul> <p>If you prefer to do away with having to setup your own Kubernetes environment, Killercoda offers a simple browser-based interactive environment.  The Istio 0 to 60 scenarios have been ported to Killercoda and can be launched from here.</p> <p>If you choose this option, please disregard this page's remaining instructions.</p> <p>Yet another option is to run a Kubernetes cluster on your local machine using Minikube, Kind, or similar tooling.  This option entails minimum resource (cpu and memory) requirements and you will need to ensure that ingress to loadbalancer-type services functions.  Here is a recipe for creating a local Kubernetes cluster with k3d:</p> <pre><code>k3d cluster create my-istio-cluster \\\n    --api-port 6443 \\\n    --k3s-arg \"--disable=traefik@server:0\" \\\n    --port 80:80@loadbalancer \\\n    --port 443:443@loadbalancer\n</code></pre> <p>Tip</p> <p>This workshop makes extensive use of the <code>kubectl</code> CLI.</p> <p>Consider configuring an alias to make typing a little easier.  Here are commands to configure the \"k\" alias with command completion, for the bash shell:</p> <pre><code>cat &lt;&lt; EOF &gt;&gt; ~/.bashrc\n\nsource &lt;(kubectl completion bash)\nalias k=kubectl\ncomplete -F __start_kubectl k\n\nEOF\n\nsource ~/.bashrc\n</code></pre>"},{"location":"environment/#log-in-to-gcp","title":"Log in to GCP","text":"<ol> <li>Log in to GCP using credentials provided by your instructor.</li> <li>Agree to the terms</li> <li>You will be prompted to select your country, click \"Agree and continue\"</li> </ol>"},{"location":"environment/#select-your-project","title":"Select your project","text":"<p>Select the GCP project you have been assigned, as follows:</p> <ol> <li>Click the project selector \"pulldown\" menu from the top banner, which will open a popup dialog</li> <li>Make sure the Select from organization is set to tetratelabs.com</li> <li>Select the tab named All</li> <li>You will see your GCP project name (istio-0to60..) listed under the organization tetratelabs.com</li> <li>Select the project from the list</li> </ol> <p>Verify that your project is selected:</p> <ul> <li>If you look in the banner now, you will see your selected project displayed.</li> </ul>"},{"location":"environment/#launch-the-cloud-shell","title":"Launch the Cloud Shell","text":"<p>The Google Cloud Shell will serve as your terminal environment for these labs.</p> <ul> <li>Click the Activate cloud shell icon (top right); the icon looks like this: </li> <li>A dialog may pop up, click Continue</li> <li>Your cloud shell terminal should appear at the bottom of the screen</li> <li>Feel free to expand the size of the cloud shell, or even open it in a separate window (locate the icon button  in the terminal header, on the right)</li> </ul> <p>Warning</p> <p>Your connection to the Cloud Shell gets severed after a period of inactivity. Click on the Reconnect button when this happens.</p>"},{"location":"environment/#configure-cluster-access","title":"Configure cluster access","text":"<ol> <li> <p>Check that the <code>kubectl</code> CLI is installed</p> <pre><code>kubectl version --short\n</code></pre> </li> <li> <p>Generate a <code>kubeconfig</code> entry</p> With the user interfaceFrom the command line <ol> <li>Activate the top navigation menu (Menu icon on the top left hand side of the page)</li> <li>Locate and click on the product Kubernetes Engine (you may have to scroll down until you see it)</li> <li>Your pre-provisioned 3-node Kubernetes cluster should appear in the main view</li> <li>Click on that row's \"three dot\" menu and select the Connect option</li> <li>A dialog prompt will appear with instructions</li> <li>Copy the <code>gcloud</code> command shown and paste it in your cloud shell</li> </ol> <pre><code>gcloud container clusters get-credentials \\\n    $(gcloud container clusters list --format=\"value(name)\") \\\n    --zone $(gcloud container clusters list --format=\"value(location)\") \\\n    --project $(gcloud config get-value project)\n</code></pre> <p>Click Authorize when prompted</p> <p>The console message will state that a kubeconfig entry [was] generated for [your project]</p> </li> <li> <p>Verify that your Kubernetes context is set for your cluster</p> <pre><code>kubectl config get-contexts\n</code></pre> </li> <li> <p>Run a token command such as <code>kubectl get node</code> or <code>kubectl get ns</code> to ensure that you can communicate with the Kubernetes API Server.</p> <pre><code>kubectl get ns\n</code></pre> </li> </ol> <p>Instructions in subsequent labs assume you will be working from the Google Cloud Shell.</p>"},{"location":"environment/#artifacts","title":"Artifacts","text":"<p>The lab instructions reference Kubernetes yaml artifacts that you will need to apply to your cluster at specific points in time.</p> <p>You have the option of copying and pasting the yaml snippets directly from the lab instructions as you encounter them.</p> <p>Another option is to clone the GitHub repository for this workshop from the Cloud Shell.  You will find all yaml artifacts in the subdirectory named <code>artifacts</code>.</p> <pre><code>git clone https://github.com/tetratelabs/istio-0to60.git &amp;&amp; \\\n  mv istio-0to60/artifacts . &amp;&amp; \\\n  rm -rf istio-0to60\n</code></pre>"},{"location":"environment/#next","title":"Next","text":"<p>Now that we have access to our environment and to our Kubernetes cluster, we can proceed to install Istio.</p>"},{"location":"ingress-gwapi/","title":"Ingress with the Kubernetes Gateway API","text":"<p>Like the previous lab, the objective of this lab is to expose the <code>web-frontend</code> service to the internet.</p> <p>Rather than use the Istio native <code>Gateway</code> and <code>VirtualService</code> resources, in this lab the implementation leverages the Kubernetes Gateway API.</p> <p>When using K3D</p> <p>This lab is not yet compatible with a local Kubernetes cluster setup using K3D.</p>"},{"location":"ingress-gwapi/#prerequisites","title":"Prerequisites","text":"<p>Install the Kubernetes Gateway API Custom Resource Definitions (CRDs):</p> <pre><code>kubectl kustomize \"github.com/kubernetes-sigs/gateway-api/config/crd?ref=v1.0.0\" | kubectl apply -f -\n</code></pre>"},{"location":"ingress-gwapi/#the-ingress-gateway","title":"The Ingress gateway","text":"<p>When you installed Istio, in addition to deploying <code>istiod</code> to Kubernetes, the installation also provisioned an Ingress Gateway.</p> <p>Unlike Istio, with the Kubernetes Gateway API, a Gateway is deployed implicitly when a Gateway resource is applied to the Kubernetes cluster.</p> <p>That is, this solution will not utilize the ingress gateway already deployed and running in the <code>istio-system</code> namespace.</p>"},{"location":"ingress-gwapi/#configuring-the-gateway","title":"Configuring the Gateway","text":"<p>The K8S Gateway API preserves Istio's design of separating the configuration of the Gateway from the routing concerns by using two distinct resources.  The Gateway API of course defines its own CRDs:</p> <ol> <li><code>Gateway</code> (although the resource name is the same, the <code>apiVersion</code> field is <code>gateway.networking.k8s.io/v1beta1</code>)</li> <li><code>HttpRoute</code></li> </ol>"},{"location":"ingress-gwapi/#create-a-gateway-resource","title":"Create a Gateway resource","text":"<ol> <li> <p>Review the following Gateway specification.</p> <p>k8s-gw.yaml</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: frontend-gateway\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: http\n    port: 80\n    protocol: HTTP\n    allowedRoutes:\n      namespaces:\n        from: Same\n</code></pre> <p>Above, we specify the HTTP protocol and port 80.  We leave the optional <code>hostname</code> field blank, to allow any ingress request to match.  This is similar to using a wildcard (\"*\") host matcher in Istio.</p> </li> <li> <p>Apply the gateway resource to your cluster.</p> <pre><code>kubectl apply -f k8s-gw.yaml\n</code></pre> </li> </ol> <p>Before proceeding, wait until the associated Gateway deployment is provisioned:</p> <pre><code>kubectl wait --for=condition=programmed gtw frontend-gateway\n</code></pre> <p>Note above how the short name for this Gateway resource is <code>gtw</code> (Istio's Gateway resource's short name is <code>gw</code>).</p>"},{"location":"ingress-gwapi/#verify-the-gateway-deployment","title":"Verify the Gateway deployment","text":"<p>Note that a gateway deployment by the name of <code>frontend-gateway-istio</code> has been created:</p> <pre><code>kubectl get deploy\n</code></pre> <p>A corresponding LoadBalancer type service was also created:</p> <pre><code>kubectl get svc\n</code></pre> <p>Make a note of the external IP address for the load balancer.</p> <p>Assign it to an environment variable.</p> <pre><code>export GATEWAY_IP=$(kubectl get svc frontend-gateway-istio -ojsonpath='{.status.loadBalancer.ingress[0].ip}')\n</code></pre>  A small investment <p>When the cloud shell connection is severed, or when opening a new terminal tab, <code>$GATEWAY_IP</code> will no longer be in scope.</p> <p>Ensure <code>GATEWAY_IP</code> is set each time we start a new shell:</p> <pre><code>cat &lt;&lt; EOF &gt;&gt; ~/.bashrc\n\nexport GATEWAY_IP=$(kubectl get svc frontend-gateway-istio -ojsonpath='{.status.loadBalancer.ingress[0].ip}')\n\nEOF\n</code></pre> <p>In normal circumstances we associate this IP address with a hostname via DNS. For the sake of simplicity, in this workshop we use the gateway public IP address directly.</p>"},{"location":"ingress-gwapi/#configure-routing","title":"Configure routing","text":"<p>Attempt an HTTP request in your browser to the gateway IP address.  It should return a 404 (not found).</p> <p>Let us \"fix\" that issue by defining a route to the <code>web-frontend</code> service.</p> <ol> <li> <p>Review the following <code>HttpRoute</code> specification.</p> web-frontend-route.yaml <pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: web-frontend\nspec:\n  parentRefs:\n  - name: frontend-gateway\n  rules:\n  - backendRefs:\n    - name: web-frontend\n      port: 80\n</code></pre> <p>Note how this specification references the name of the gateway (\"frontend-gateway\").  The absence of a matching hostname will direct all requests to the <code>web-frontend</code> service, irrespective of host name.</p> </li> <li> <p>Apply the <code>HttpRoute</code> resource to your cluster.</p> <pre><code>kubectl apply -f web-frontend-route.yaml\n</code></pre> </li> <li> <p>List HTTP routes in the default namespace.</p> <pre><code>kubectl get httproute\n</code></pre> <p>The output indicates that the HTTP route named <code>web-frontend</code> is bound to the gateway, as well as any hostname that routes to the load balancer IP address.</p> </li> </ol> <p>Finally, verify that you can now access <code>web-frontend</code> from your web browser using the gateway IP address.</p> <p>What if I wanted to configure ingress with TLS?</p> <p>Here is a recipe that illustrates how to configure secure ingress with a self-signed certificate:</p> <ol> <li> <p>Generate the certificate:</p> <ol> <li> <p>Generate a self-signed root certificate in the folder <code>example_certs</code></p> <pre><code>mkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example_certs/example.com.key -out example_certs/example.com.crt\n</code></pre> </li> <li> <p>Generate a certificate and private key for the hostname <code>webfrontend.example.com</code>:</p> <pre><code>openssl req -out example_certs/webfrontend.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs/webfrontend.example.com.key -subj \"/CN=webfrontend.example.com/O=webfrontend organization\"\nopenssl x509 -req -sha256 -days 365 -CA example_certs/example.com.crt -CAkey example_certs/example.com.key -set_serial 0 -in example_certs/webfrontend.example.com.csr -out example_certs/webfrontend.example.com.crt\n</code></pre> </li> </ol> </li> <li> <p>Store the certificate as a secret in your Kubernetes cluster:</p> <pre><code>kubectl create -n default secret tls webfrontend-credential \\\n  --key=example_certs/webfrontend.example.com.key \\\n  --cert=example_certs/webfrontend.example.com.crt\n</code></pre> </li> <li> <p>Revise the gateway configuration to listen on port 443, and to reference the secret that the envoy listeners will present to incoming requests:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: frontend-gateway\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: https\n    hostname: webfrontend.example.com\n    port: 443\n    protocol: HTTPS\n    tls:\n      certificateRefs:\n      - name: webfrontend-credential\n    allowedRoutes:\n      namespaces:\n        from: Same\n</code></pre> </li> <li> <p>Apply the revised gateway configuration:</p> <pre><code>kubectl apply -f k8s-gw-tls.yaml\n</code></pre> </li> <li> <p>Test your implementation by making a request to the ingress gateway:</p> <pre><code>curl -s -v --head -k https://webfrontend.example.com/ --resolve webfrontend.example.com:443:$GATEWAY_IP\n</code></pre> </li> </ol> <p>See the Istio documentation for additional examples relating to the topic of configuring secure gateways.</p>"},{"location":"ingress-gwapi/#next","title":"Next","text":"<p>The application is now running and exposed on the internet.</p> <p>In the next lab, we turn our attention to the observability features that are built in to Istio.</p>"},{"location":"ingress/","title":"Ingress","text":"<p>The objective of this lab is to expose the <code>web-frontend</code> service to the internet.</p>"},{"location":"ingress/#the-ingress-gateway","title":"The Ingress gateway","text":"<p>When you installed Istio, in addition to deploying <code>istiod</code> to Kubernetes, the installation also provisioned an Ingress Gateway.</p> <p>View the corresponding Istio ingress gateway pod in the <code>istio-system</code> namespace.</p> <pre><code>kubectl get pod -n istio-system\n</code></pre> <p>A corresponding LoadBalancer type service was also created:</p> <pre><code>kubectl get svc -n istio-system\n</code></pre> <p>Make a note of the external IP address for the load balancer.</p> <p>Assign it to an environment variable.</p> <pre><code>export GATEWAY_IP=$(kubectl get svc -n istio-system istio-ingressgateway \\\n    -ojsonpath='{.status.loadBalancer.ingress[0].ip}')\n</code></pre> <p>When using K3D</p> <p>If you have opted to run Kubernetes directly on your local machine with K3D, use \"127.0.0.1\" instead:</p> <pre><code>export GATEWAY_IP=127.0.0.1\n</code></pre>  A small investment <p>When the cloud shell connection is severed, or when opening a new terminal tab, <code>$GATEWAY_IP</code> will no longer be in scope.</p> <p>Ensure <code>GATEWAY_IP</code> is set each time we start a new shell:</p> <pre><code>cat &lt;&lt; EOF &gt;&gt; ~/.bashrc\n\nexport GATEWAY_IP=$(kubectl get svc -n istio-system istio-ingressgateway -ojsonpath='{.status.loadBalancer.ingress[0].ip}')\n\nEOF\n</code></pre> <p>In normal circumstances we associate this IP address with a hostname via DNS. For the sake of simplicity, in this workshop we will use the gateway public IP address directly.</p>"},{"location":"ingress/#configuring-ingress","title":"Configuring ingress","text":"<p>Configuring ingress with Istio is performed in two parts:</p> <ol> <li>Define a <code>Gateway</code> Custom Resource that governs the specific host, port, and protocol to expose.</li> <li>Specify how requests should be routed with a <code>VirtualService</code> Custom Resource.</li> </ol>"},{"location":"ingress/#create-a-gateway-resource","title":"Create a Gateway resource","text":"<ol> <li> <p>Review the following Gateway specification.</p> <p>gateway.yaml</p> <pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: frontend-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 80\n      name: http\n      protocol: HTTP\n    hosts:\n    - \"*\"\n</code></pre> <p>Above, we specify the HTTP protocol, port 80, and a wildcard (\"*\") host matcher which ensures that HTTP requests using the load balancer IP address <code>$GATEWAY_IP</code> will match.</p> <p>The selector istio: ingressgateway selects the Envoy gateway workload to be configured, the one residing in the <code>istio-system</code> namespace.</p> </li> <li> <p>Apply the gateway resource to your cluster.</p> <pre><code>kubectl apply -f gateway.yaml\n</code></pre> </li> <li> <p>Attempt an HTTP request in your browser to the gateway IP address.</p> <pre><code>curl -v http://$GATEWAY_IP/\n</code></pre> <p>It should return a 404: not found.</p> </li> </ol>"},{"location":"ingress/#create-a-virtualservice-resource","title":"Create a VirtualService resource","text":"<ol> <li> <p>Review the following VirtualService specification.</p> web-frontend-virtualservice.yaml <pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: web-frontend\nspec:\n  hosts:\n  - \"*\"\n  gateways:\n  - frontend-gateway\n  http:\n  - route:\n    - destination:\n        host: web-frontend.default.svc.cluster.local\n        port:\n          number: 80\n</code></pre> <p>Note how this specification references the name of the gateway (\"frontend-gateway\"), a matching host (\"*\"), and specifies a route for requests to be directed to the <code>web-frontend</code> service.</p> </li> <li> <p>Apply the VirtualService resource to your cluster.</p> <pre><code>kubectl apply -f web-frontend-virtualservice.yaml\n</code></pre> </li> <li> <p>List virtual services in the default namespace.</p> <pre><code>kubectl get virtualservice\n</code></pre> <p>The output indicates that the VirtualService named <code>web-frontend</code> is bound to the gateway <code>frontend-gateway</code>, as well as any hostname that routes to the load balancer IP address.</p> </li> </ol> <p>Finally, verify that you can now access <code>web-frontend</code> from your web browser using the gateway IP address.</p> <p>What if I wanted to configure ingress with TLS?</p> <p>Here is a recipe that illustrates how to configure secure ingress with a self-signed certificate:</p> <ol> <li> <p>Generate the certificate:</p> <ol> <li> <p>Generate a self-signed root certificate in the folder <code>example_certs</code></p> <pre><code>mkdir example_certs\nopenssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -subj '/O=example Inc./CN=example.com' -keyout example_certs/example.com.key -out example_certs/example.com.crt\n</code></pre> </li> <li> <p>Generate a certificate and private key for the hostname <code>webfrontend.example.com</code>:</p> <pre><code>openssl req -out example_certs/webfrontend.example.com.csr -newkey rsa:2048 -nodes -keyout example_certs/webfrontend.example.com.key -subj \"/CN=webfrontend.example.com/O=webfrontend organization\"\nopenssl x509 -req -sha256 -days 365 -CA example_certs/example.com.crt -CAkey example_certs/example.com.key -set_serial 0 -in example_certs/webfrontend.example.com.csr -out example_certs/webfrontend.example.com.crt\n</code></pre> </li> </ol> </li> <li> <p>Store the certificate as a secret in your Kubernetes cluster:</p> <pre><code>kubectl create -n istio-system secret tls webfrontend-credential \\\n  --key=example_certs/webfrontend.example.com.key \\\n  --cert=example_certs/webfrontend.example.com.crt\n</code></pre> </li> <li> <p>Revise the gateway configuration to listen on port 443, and to reference the secret that the envoy listeners will present to incoming requests:</p> <pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n  name: frontend-gateway\nspec:\n  selector:\n    istio: ingressgateway\n  servers:\n  - port:\n      number: 443\n      name: https\n      protocol: HTTPS\n    tls:\n      mode: SIMPLE\n      credentialName: webfrontend-credential\n    hosts:\n    - webfrontend.example.com\n</code></pre> </li> <li> <p>Apply the revised gateway configuration:</p> <pre><code>kubectl apply -f gateway-tls.yaml\n</code></pre> </li> <li> <p>Test your implementation by making a request to the ingress gateway:</p> <pre><code>curl -k https://webfrontend.example.com/ --resolve webfrontend.example.com:443:$GATEWAY_IP\n</code></pre> </li> </ol> <p>See the Istio documentation for additional examples relating to the topic of configuring secure gateways.</p>"},{"location":"ingress/#next","title":"Next","text":"<p>The application is now running and exposed on the internet.</p> <p>In the next lab, we turn our attention to the observability features that are built into Istio.</p>"},{"location":"install/","title":"Install Istio","text":"<p>In this lab you will install Istio.</p>"},{"location":"install/#download-istio","title":"Download Istio","text":"<ol> <li> <p>Run the following command from your home directory.</p> <pre><code>curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.21.0 sh -\n</code></pre> </li> <li> <p>Navigate into the directory created by the above command.</p> <pre><code>cd istio-1.21.0\n</code></pre> </li> </ol>"},{"location":"install/#add-istioctl-to-your-path","title":"Add <code>istioctl</code> to your PATH","text":"<p>The <code>istioctl</code> CLI is located in the <code>bin/</code> subdirectory.</p> <p> Workaround for the Google Cloud Shell</p> <p>Cloud Shell only preserves files located inside your home directory across sessions.</p> <p>This means that if you install a binary to a <code>PATH</code> such as <code>/usr/local/bin</code>, after your session times out that file may no longer be there!</p> <p>As a workaround, you will add <code>${HOME}/bin</code> to your <code>PATH</code> and place the binary there.</p> <ol> <li> <p>Create a <code>bin</code> subdirectory in your home directory:</p> <pre><code>mkdir ~/bin\n</code></pre> </li> <li> <p>Copy the CLI to that subdirectory:</p> <pre><code>cp ./bin/istioctl ~/bin\n</code></pre> </li> <li> <p>Add your home <code>bin</code> subdirectory to your <code>PATH</code></p> <pre><code>cat &lt;&lt; EOF &gt;&gt; ~/.bashrc\n\nexport PATH=\"~/bin:\\$PATH\"\n\nEOF\n</code></pre> <p>And then:</p> <pre><code>source ~/.bashrc\n</code></pre> </li> </ol> <p>Verify that <code>istioctl</code> is installed with:</p> <pre><code>istioctl version\n</code></pre> <p>The output should indicate that the version is 1.21.0.</p> <p>With the CLI installed, proceed to install Istio to Kubernetes.</p>"},{"location":"install/#pre-check","title":"Pre-check","text":"<p>The <code>istioctl</code> CLI provides a convenient <code>precheck</code> command that can be used to \"inspect a Kubernetes cluster for Istio install and upgrade requirements.\"</p> <p>To verify whether it is safe to install Istio on your Kubernetes cluster, run:</p> <pre><code>istioctl x precheck\n</code></pre> <p>Make sure that the output of the above command returns a green \"checkmark\" stating that no issues were found when checking the cluster.</p>"},{"location":"install/#install-istio_1","title":"Install Istio","text":"<ol> <li> <p>Istio can be installed directly with the CLI:</p> <pre><code>istioctl install\n</code></pre> </li> <li> <p>When prompted, enter <code>y</code> to proceed to install Istio.</p> </li> </ol> <p>Take a moment to learn more about Istio installation profiles.</p>"},{"location":"install/#verify-that-istio-is-installed","title":"Verify that Istio is installed","text":"<p>Post-installation, Istio provides the command <code>verify-install</code>: it runs a series of checks to ensure that the installation was successful and complete.</p> <p>Go ahead and run it:</p> <pre><code>istioctl verify-install\n</code></pre> <p>Inspect the output and confirm that the it states that \"\u2714 Istio is installed and verified successfully.\"</p> <p>Keep probing:</p> <ol> <li> <p>List Kubernetes namespaces and note the new namespace <code>istio-system</code></p> <pre><code>kubectl get ns\n</code></pre> </li> <li> <p>Verify that the <code>istiod</code> controller pod is running in that namespace</p> <pre><code>kubectl get pod -n istio-system\n</code></pre> </li> <li> <p>Re-run <code>istioctl version</code>.  The output should include a control plane version, indicating that Istio is indeed present in the cluster.</p> </li> </ol>"},{"location":"install/#next","title":"Next","text":"<p>With Istio installed, we are ready to deploy an application to the mesh.</p>"},{"location":"security/","title":"Security","text":"<p>In this lab we explore some of the security features of the Istio service mesh.</p>"},{"location":"security/#mutual-tls","title":"Mutual TLS","text":"<p>By default, Istio is configured such that when a service is deployed onto the mesh, it will take advantage of mutual TLS:</p> <ul> <li>Workloads are given an identity as a function of their associated service account and namespace.</li> <li>An x.509 certificate is issued to the workload (and regularly rotated) and used to identify the workload in calls to other services.</li> </ul> <p>In the observability lab, we looked at the Kiali dashboard and noted the  icons indicating that traffic was secured with mTLS.</p>"},{"location":"security/#can-a-workload-receive-plain-text-requests","title":"Can a workload receive plain-text requests?","text":"<p>We can test whether a mesh workload, such as the <code>customers</code> service, will allow a plain-text request as follows:</p> <ol> <li> <p>Create a separate namespace that is not configured with automatic injection.</p> <pre><code>kubectl create ns other-ns\n</code></pre> </li> <li> <p>Deploy <code>sleep</code> to that namespace</p> <pre><code>kubectl apply -f sleep.yaml -n other-ns\n</code></pre> </li> <li> <p>Verify that the sleep pod has no sidecars:</p> <pre><code>kubectl get pod -n other-ns\n</code></pre> </li> <li> <p>Call the customer service from that pod:</p> <pre><code>kubectl exec -n other-ns deploy/sleep -- curl -s customers.default\n</code></pre> </li> </ol> <p>The output is a JSON-formatted list of customers.</p> <p>We conclude that Istio is configured by default to allow plain-text request. This is called permissive mode and is specifically designed to allow services that have not yet fully on-boarded onto the mesh to participate.</p>"},{"location":"security/#enable-strict-mode","title":"Enable strict mode","text":"<p>Istio provides the <code>PeerAuthentication</code> custom resource to specify peer authentication policy.</p> <ol> <li> <p>Review the following policy.</p> <p>mtls-strict.yaml</p> <pre><code>---\napiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: default\n  namespace: default\nspec:\n  mtls:\n    mode: STRICT\n</code></pre> <p>Info</p> <p>Strict mtls can be enabled globally by setting the namespace to the name of the Istio root namespace, which by default is <code>istio-system</code></p> </li> <li> <p>Apply the <code>PeerAuthentication</code> resource to the cluster.</p> <pre><code>kubectl apply -f mtls-strict.yaml\n</code></pre> </li> <li> <p>Verify that the peer authentication has been applied.</p> <pre><code>kubectl get peerauthentication\n</code></pre> </li> </ol>"},{"location":"security/#verify-that-plain-text-requests-are-no-longer-permitted","title":"Verify that plain-text requests are no longer permitted","text":"<pre><code>kubectl exec -n other-ns deploy/sleep -- curl customers.default\n</code></pre> <p>The console output should indicate that the connection was reset by peer.</p>"},{"location":"security/#inspecting-a-workload-certificate","title":"Inspecting a workload certificate","text":"<ol> <li> <p>Capture the certificate returned by the <code>customers</code> workload:</p> <pre><code>kubectl exec deploy/sleep -c istio-proxy -- \\\nopenssl s_client -showcerts -connect customers:80 &gt; cert.txt\n</code></pre> </li> <li> <p>Inspect the certificate with:</p> <pre><code>openssl x509 -in cert.txt -text -noout\n</code></pre> </li> <li> <p>Review the certificate fields:</p> <ol> <li>The certificate validity period should be 24 hrs.</li> <li>The Subject Alternative Name field should contain the spiffe URI.</li> </ol> </li> </ol> <p>How do I know that traffic is mTls-encrypted?</p> <p>Here is a recipe that uses the <code>tcpdump</code> utility to spy on traffic to a service to verify that it is indeed encrypted.</p> <ol> <li> <p>Update the Istio installation with the configuration field <code>values.proxy.privileged</code> set to <code>true</code>:</p> <pre><code>istioctl install --set values.global.proxy.privileged=true\n</code></pre> <p>For a description of this configuration field, see the output of <code>helm show values istio/istiod | grep privileged</code>.</p> </li> <li> <p>Restart the <code>customers</code> deployment:</p> <pre><code>kubectl rollout restart deploy customers-v1\n</code></pre> </li> <li> <p>Grab the IP address of the customers Pod:</p> <pre><code>IP_ADDRESS=$(kubectl get pod -l app=customers -o jsonpath='{.items[0].status.podIP}')\n</code></pre> </li> <li> <p>Shell into the <code>customers</code> sidecar container:</p> <pre><code>kubectl exec -it svc/customers -c istio-proxy -- env IP_ADDRESS=$IP_ADDRESS /bin/bash\n</code></pre> </li> <li> <p>Start <code>tcpdump</code> on the port that the <code>customers</code> service is listening on:</p> <pre><code>sudo tcpdump -vvvv -A -i eth0 \"((dst port 3000) and (net ${IP_ADDRESS}))\"\n</code></pre> </li> <li> <p>In separate terminal make a call to the customers service:</p> <pre><code>kubectl exec deploy/sleep -- curl customers\n</code></pre> </li> </ol> <p>You will see encrypted text in the <code>tcpdump</code> output.</p>"},{"location":"security/#security-in-depth","title":"Security in depth","text":"<p>Another important layer of security is to define an authorization policy, in which we allow only specific services to communicate with other services.</p> <p>At the moment, any container can, for example, call the customers service or the web-frontend service.</p> <ol> <li> <p>Call the <code>customers</code> service.</p> <pre><code>kubectl exec deploy/sleep -- curl -s customers\n</code></pre> </li> <li> <p>Call the <code>web-frontend</code> service.</p> <pre><code>kubectl exec deploy/sleep -- curl -s web-frontend | head\n</code></pre> </li> </ol> <p>Both calls succeed.</p> <p>We wish to apply a policy in which only <code>web-frontend</code> is allowed to call <code>customers</code>, and only the ingress gateway can call <code>web-frontend</code>.</p> <p>Study the below authorization policy.</p> <p>authz-policy-customers.yaml</p> <pre><code>---\napiVersion: security.istio.io/v1beta1\nkind: AuthorizationPolicy\nmetadata:\n  name: allowed-customers-clients\n  namespace: default\nspec:\n  selector:\n    matchLabels:\n        app: customers\n  action: ALLOW\n  rules:\n  - from:\n    - source:\n        principals: [\"cluster.local/ns/default/sa/web-frontend\"]\n</code></pre> <ul> <li>The <code>selector</code> section specifies that the policy applies to the <code>customers</code> service.</li> <li>Note how the rules have a \"from: source: \" section indicating who is allowed in.</li> <li>The nomenclature for the value of the <code>principals</code> field comes from the spiffe standard.  Note how it captures the service account name and namespace associated with the <code>web-frontend</code> service.  This identity is associated with the x.509 certificate used by each service when making secure mtls calls to one another.</li> </ul> <p>Tasks:</p> <ul> <li> Apply the policy to your cluster.</li> <li> Verify that you are no longer able to reach the <code>customers</code> pod from the <code>sleep</code> pod</li> </ul>"},{"location":"security/#challenge","title":"Challenge","text":"<p>Can you come up with a similar authorization policy for <code>web-frontend</code>?</p> <ul> <li>Use a copy of the <code>customers</code> authorization policy as a starting point</li> <li>Give the resource an apt name</li> <li>Revise the selector to match the <code>web-frontend</code> service</li> <li>Revise the rule to match the principal of the ingress gateway</li> </ul> <p>Hint</p> <p>The ingress gateway has its own identity.</p> <p>Here is a command which can help you find the name of the service account associated with its identity:</p> <pre><code>kubectl get pod -n istio-system -l app=istio-ingressgateway -o yaml | grep serviceAccountName\n</code></pre> <p>Use this service account name together with the namespace that the ingress gateway is running in to specify the value for the <code>principals</code> field.</p>"},{"location":"security/#test-it","title":"Test it","text":"<p>Don't forget to verify that the policy is enforced.</p> <ul> <li>Call both services again from the sleep pod and ensure communication is no longer allowed.</li> <li>The console output should contain the message RBAC: access denied.</li> </ul>"},{"location":"security/#next","title":"Next","text":"<p>In the next lab we show how to use Istio's traffic management features to upgrade the <code>customers</code> service with zero downtime.</p>"},{"location":"sidecar-injection/","title":"Sidecar injection","text":"<p>This lab explores sidecar injection in Istio.</p>"},{"location":"sidecar-injection/#preface","title":"Preface","text":"<p>Istio provides both a manual and an automatic mechanism for injecting sidecars alongside workloads.</p> <p>In this lab you will use the manual method, because it provides the opportunity to inspect the transformed deployment manifest even before applying it to a target Kubernetes cluster.</p> <p>You will learn about automatic sidecar injection in the next lab.</p>"},{"location":"sidecar-injection/#generate-a-pod-spec","title":"Generate a Pod spec","text":"<p>The <code>kubectl</code> command's <code>dry-run</code> flag provides a simple way to generate and capture a simple pod specification.</p> <p>Generate a Pod spec for a simple web server, as follows:</p> <pre><code>kubectl run mywebserver --image nginx \\\n    --dry-run=client -oyaml &gt; nginx-pod.yaml\n</code></pre> <p>Inspect the contents of the generated file.  Here it is below, slightly cleaned up:</p> nginx-pod.yaml<pre><code>---\napiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    run: mywebserver\n  name: mywebserver\nspec:\n  containers:\n  - name: mywebserver\n    image: nginx\n</code></pre> <p>The main thing to note at this point is that this Pod spec consists of a single container using the image <code>nginx</code>.</p>"},{"location":"sidecar-injection/#transform-the-pod-spec","title":"Transform the Pod spec","text":"<p>The <code>istioctl</code> command provides the convenient <code>kube-inject</code> subcommand, that can transform such a specification into one that includes the necessary sidecar.</p> <ol> <li> <p>Learn the <code>kube-inject</code> command's usage:</p> <pre><code>istioctl kube-inject --help\n</code></pre> </li> <li> <p>Use the command to generate and capture the full sidecar-injected manifest to a new file named <code>transformed.yaml</code>.</p> Show me how <pre><code>istioctl kube-inject --filename ./nginx-pod.yaml &gt; transformed.yaml\n</code></pre> </li> </ol>"},{"location":"sidecar-injection/#study-the-sidecar-container-specification","title":"Study the sidecar container specification","text":"<p>The modified Pod specification now includes a second container.</p> <p>Here is the salient part:</p> <pre><code>  - name: istio-proxy\n    image: docker.io/istio/proxyv2:1.21.0\n    args:\n    - proxy\n    - sidecar\n    - --domain\n    - $(POD_NAMESPACE).svc.cluster.local\n    - --proxyLogLevel=warning\n    - --proxyComponentLogLevel=misc:error\n    - --log_output_level=default:info\n    - --concurrency\n    - \"2\"\n    env:\n    - ...\n</code></pre> <p>The container name is <code>istio-proxy</code> and the docker image is <code>istio/proxyv2</code>.</p> What command is actually run? <p>To find out what command actually runs inside that container, we can inspect the docker container specification and view the Entrypoint field:</p> <pre><code>docker pull docker.io/istio/proxyv2:1.21.0\ndocker inspect istio/proxyv2:1.21.0 | grep Entrypoint -A 2\n</code></pre> <p>Here is the output:</p> <pre><code>\"Entrypoint\": [\n    \"/usr/local/bin/pilot-agent\"\n],\n</code></pre> <p>We learn that the name of the command is <code>pilot-agent</code>.</p> <p>By extracting the arguments from the yaml, we can reconstitute the full command executed inside the sidecar container:</p> <pre><code>pilot-agent proxy sidecar \\\n    --domain $(POD_NAMESPACE).svc.cluster.local \\\n    --proxyLogLevel=warning \\\n    --proxyComponentLogLevel=misc:error \\\n    --log_output_level=default:info \\\n    --concurrency \"2\"\n</code></pre>"},{"location":"sidecar-injection/#apply-the-manifest","title":"Apply the manifest","text":"<ol> <li> <p>Deploy the transformed manifest to Kubernetes:</p> <pre><code>kubectl apply -f transformed.yaml\n</code></pre> </li> <li> <p>List pods in the <code>default</code> namespace</p> <pre><code>kubectl get pod\n</code></pre> <p>Once the pod reaches <code>Running</code> state, note the <code>READY</code> column in the output displays 2 out of 2 containers:</p> <pre><code>NAME          READY   STATUS    RESTARTS   AGE\nmywebserver   2/2     Running   0          36s\n</code></pre> </li> </ol>"},{"location":"sidecar-injection/#study-the-running-processes","title":"Study the running processes","text":"<p>Run the <code>ps</code> command from inside the sidecar container, like so:</p> <pre><code>kubectl exec mywebserver -c istio-proxy -- ps -ef\n</code></pre> <p>Here is the output, slightly cleaned up, showing both the <code>pilot-agent</code> process, and the <code>envoy</code> process that it bootstrapped:</p> <pre><code>PID  PPID CMD\n  1     0 /usr/local/bin/pilot-agent proxy sidecar --domain ...\n 16     1 /usr/local/bin/envoy -c etc/istio/proxy/envoy-rev.json ...\n</code></pre> <p>We can learn more about the <code>pilot-agent</code> command by running <code>pilot-agent --help</code> from inside the sidecar container:</p> <pre><code>kubectl exec mywebserver -c istio-proxy -- pilot-agent --help\n</code></pre>"},{"location":"sidecar-injection/#study-the-initcontainers-specification","title":"Study the <code>initContainers</code> specification","text":"<p>Besides injecting a sidecar container, the transformation operation also adds an initContainers section.</p> <p>Here is the relevant section:</p> <pre><code>  initContainers:\n  - name: istio-init\n    image: docker.io/istio/proxyv2:1.21.0\n    args:\n    - istio-iptables\n    - -p\n    - \"15001\"\n    - -z\n    - \"15006\"\n    - -u\n    - \"1337\"\n    - -m\n    - REDIRECT\n    - -i\n    - '*'\n    - -x\n    - \"\"\n    - -b\n    - '*'\n    - -d\n    - 15090,15021,15020\n    - --log_output_level=default:info\n</code></pre> <p>The \"initContainer\" uses the same image as the sidecar container: <code>istio/proxyv2</code>.  The difference lies in the command that is run when the Pod initializes.</p> <p>Here is the reconstituted command with long-form versions of each option, to clarify the instruction:</p> <pre><code>pilot-agent istio-iptables \\\n    --envoy-port \"15001\" \\\n    --inbound-capture-port \"15006\" \\\n    --proxy-uid \"1337\" \\\n    --istio-inbound-interception-mode REDIRECT \\\n    --istio-service-cidr '*' \\\n    --istio-service-exclude-cidr \"\" \\\n    --istio-inbound-ports '*' \\\n    --istio-local-exclude-ports 15090,15021,15020 \\\n    --log_output_level=default:info\n</code></pre> Tip <p>For a full description of the <code>istio-iptables</code> subcommand and its options, run:</p> <pre><code>kubectl exec mywebserver -c istio-proxy -- pilot-agent istio-iptables --help\n</code></pre> <p>The gist of the command is that, through <code>iptables</code> rules, the routing of network packets inside the Pod is reconfigured to give Envoy the chance to intercept and proxy inbound and outbound traffic.</p> <p>We need not concern ourselves with the specific port numbers, exclusions, and other low-level details at this time.</p> <p>The lesson of this exercise is to learn how to get at these details.</p>"},{"location":"sidecar-injection/#going-forward","title":"Going forward..","text":"<p>The above process of transforming a deployment manifest on its way to the Kube API Server is streamlined when using automatic sidecar injection.</p> <p>The next lab will walk you through how automatic sidecar injection is accomplished.</p> <p>From here on, we will use automatic sidecar injection when deploying workloads to the mesh.</p>"},{"location":"sidecar-injection/#cleanup","title":"Cleanup","text":"<pre><code>kubectl delete -f transformed.yaml\n</code></pre>"},{"location":"summary/","title":"Congratulations","text":"<p>Well-done on making it all the way to the end of the Istio 0 to 60 workshop!</p> <p>In this workshop, you have covered a lot of ground!</p> <p>Let's summarize.  You have:</p> <ul> <li> Installed Istio</li> <li> Deployed an application</li> <li> Exposed the application to the internet (Ingress)</li> <li> Deployed and studied observability addons including Kiali, Zipkin, Prometheus, and Grafana</li> <li> Studied facets of service mesh security including mutual TLS and authorization policies</li> <li> Performed a traffic shifting exercise</li> <li> Circuit breakers</li> </ul> <p>Istio has many more features whose scope is beyond the 0 to 60 workshop, including but not limited to:</p> <ul> <li> Fault injection</li> <li> Extensibility with WASM</li> <li> Egress gateways</li> <li> Onboarding VM Workloads</li> <li> Istio deployment models</li> </ul> <p>We encourage you to dig deeper into the Istio docs yourself.</p> <p>You might also be interested in the free courses offered at the Tetrate Academy, including Istio Fundamentals, and Envoy Fundamentals.</p> <p>If you're interested in certification, check out the Istio Certified Associate exam.</p> <p>Finally, if you're looking for a supported, tested, and secure Istio to run in production, check out the Tetrate Istio Subscription.</p> <p>Thanks!</p>"},{"location":"the-app/","title":"The application","text":"<p>In this lab you will deploy an application to your mesh.</p> <ul> <li> <p>The application consists of two microservices, <code>web-frontend</code> and <code>customers</code>.</p> <p>Aside</p> <p>The official Istio docs canonical example is the BookInfo application.</p> <p>For this workshop, we felt that an application involving fewer microservices would be more clear.</p> </li> <li> <p>The <code>customers</code> service exposes a REST endpoint that returns a list of customers in JSON format.  The <code>web-frontend</code> calls <code>customers</code> to retrieve the list, which it uses to render to HTML.</p> </li> <li> <p>The respective Docker images for these services have already been built and pushed to a Docker registry.</p> </li> <li> <p>You will deploy the application to the <code>default</code> Kubernetes namespace.</p> </li> </ul> <p>But before proceeding, we must enable sidecar injection.</p>"},{"location":"the-app/#enable-automatic-sidecar-injection","title":"Enable automatic sidecar injection","text":"<p>There are two options for sidecar injection: automatic and manual.</p> <p>In this lab we will use automatic injection, which involves labeling the namespace where the pods are to reside.</p> <ol> <li> <p>Label the default namespace</p> <pre><code>kubectl label namespace default istio-injection=enabled\n</code></pre> </li> <li> <p>Verify that the label has been applied:</p> <pre><code>kubectl get ns -Listio-injection\n</code></pre> </li> </ol>"},{"location":"the-app/#deploy-the-application","title":"Deploy the application","text":"<ol> <li> <p>Study the two Kubernetes yaml files: <code>web-frontend.yaml</code> and <code>customers.yaml</code>.</p> web-frontend.yaml <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: web-frontend\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-frontend\n  labels:\n    app: web-frontend\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: web-frontend\n  template:\n    metadata:\n      labels:\n        app: web-frontend\n        version: v1\n    spec:\n      serviceAccountName: web-frontend\n      containers:\n      - name: web\n        image: gcr.io/tetratelabs/web-frontend:1.0.0\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8080\n        env:\n        - name: CUSTOMER_SERVICE_URL\n          value: \"http://customers.default.svc.cluster.local\"\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: web-frontend\n  labels:\n    app: web-frontend\nspec:\n  selector:\n    app: web-frontend\n  ports:\n  - port: 80\n    name: http\n    targetPort: 8080\n</code></pre> customers.yaml <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: customers\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: customers-v1\n  labels:\n    app: customers\n    version: v1\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: customers\n      version: v1\n  template:\n    metadata:\n      labels:\n        app: customers\n        version: v1\n    spec:\n      serviceAccountName: customers\n      containers:\n      - image: gcr.io/tetratelabs/customers:1.0.0\n        imagePullPolicy: Always\n        name: svc\n        ports:\n        - containerPort: 3000\n---\nkind: Service\napiVersion: v1\nmetadata:\n  name: customers\n  labels:\n    app: customers\nspec:\n  selector:\n    app: customers\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n</code></pre> <p>Each file defines its corresponding deployment, service account, and ClusterIP service.</p> </li> <li> <p>Apply the two files to your Kubernetes cluster.</p> <pre><code>kubectl apply -f customers.yaml\n</code></pre> <pre><code>kubectl apply -f web-frontend.yaml\n</code></pre> </li> </ol> <p>Confirm that:</p> <ul> <li>Two pods are running, one for each service</li> <li> <p>Each pod consists of two containers, one running the service image, the other runs the Envoy sidecar</p> <pre><code>kubectl get pod\n</code></pre> </li> </ul> <p>How did each pod end up with two containers?</p> <p>Istio installs a Kubernetes object known as a mutating webhook admission controller: logic that intercepts Kubernetes object creation requests and that has the permission to alter (mutate) what ends up stored in etcd (the pod spec).</p> <p>You can list the mutating webhooks in your Kubernetes cluster and confirm that the sidecar injector is present.</p> <pre><code>kubectl get mutatingwebhookconfigurations\n</code></pre>"},{"location":"the-app/#verify-access-to-each-service","title":"Verify access to each service","text":"<p>We wish to deploy a pod that runs a <code>curl</code> image so we can verify that each service is reachable from within the cluster. The Istio distribution provides a sample app called <code>sleep</code> that will serve this purpose.</p> <ol> <li> <p>Deploy <code>sleep</code> to the default namespace.</p> sleep.yaml <pre><code># Copyright Istio Authors\n#\n#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n\n##################################################################################################\n# Sleep service\n##################################################################################################\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: sleep\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: sleep\n  labels:\n    app: sleep\n    service: sleep\nspec:\n  ports:\n  - port: 80\n    name: http\n  selector:\n    app: sleep\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: sleep\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: sleep\n  template:\n    metadata:\n      labels:\n        app: sleep\n    spec:\n      terminationGracePeriodSeconds: 0\n      serviceAccountName: sleep\n      containers:\n      - name: sleep\n        image: curlimages/curl\n        command: [\"/bin/sleep\", \"infinity\"]\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - mountPath: /etc/sleep/tls\n          name: secret-volume\n      volumes:\n      - name: secret-volume\n        secret:\n          secretName: sleep-secret\n          optional: true\n---\n</code></pre> <pre><code>kubectl apply -f sleep.yaml\n</code></pre> </li> <li> <p>Use the <code>kubectl exec</code> command to call the <code>customers</code> service.</p> <pre><code>kubectl exec deploy/sleep -- curl -s customers\n</code></pre> <p>The console output should show a list of customers in JSON format.</p> </li> <li> <p>Call the <code>web-frontend</code> service</p> <pre><code>kubectl exec deploy/sleep -- curl -s web-frontend | head\n</code></pre> <p>The console output should show the start of an HTML page listing customers in an HTML table.</p> </li> </ol> <p>The application is now deployed and functioning.</p>"},{"location":"the-app/#next","title":"Next","text":"<p>In the next lab, we expose the <code>web-frontend</code> using an Istio Ingress Gateway.  This will allow us to access this application on the web.</p> <p>Alternatively, you have the option of exploring the future Kubernetes API Gateway version of the Ingress lab.</p>"},{"location":"traffic-shifting-gwapi/","title":"Traffic shifting with the Gateway API","text":"<p>Version 2 of the customers service has been developed, and it's time to deploy it to production. Whereas version 1 returned a list of customer names, version 2 also includes each customer's city.</p>"},{"location":"traffic-shifting-gwapi/#deploying-customers-v2","title":"Deploying customers, v2","text":"<p>We wish to deploy the new service but aren't yet ready to direct traffic to it.</p> <p>It would be prudent to separate the task of deploying the new service from the task of directing traffic to it.</p>"},{"location":"traffic-shifting-gwapi/#labels","title":"Labels","text":"<p>The customers service is labeled with <code>app=customers</code>.</p> <p>Verify this with:</p> <pre><code>kubectl get pod -Lapp,version\n</code></pre> <p>Note the selector on the <code>customers</code> service in the output to the following command:</p> <pre><code>kubectl get svc customers -o wide\n</code></pre> <p>If we were to just deploy v2, the selector would match both versions.</p>"},{"location":"traffic-shifting-gwapi/#version-specific-services","title":"Version-specific services","text":"<p>Istio has the concept of a subset, defined through a <code>DestinationRule</code> resource. The Kubernetes Gateway API does not have that concept. Instead, one can define a subset of a service's endpoints by simply defining another service with a more specific selector.</p> <p>So, for the <code>customers</code> service, we can define two subsets by using the <code>version</code> label as a discriminator, like this:</p> customers-subsets.yaml<pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v1\nspec:\n  selector:\n    app: customers\n    version: v1\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v2\nspec:\n  selector:\n    app: customers\n    version: v2\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n</code></pre> <ol> <li> <p>Apply the above resources to the cluster.</p> </li> <li> <p>Verify that two new services <code>customers-v1</code> and <code>customers-v2</code> are now defined and present:</p> <pre><code>kubectl get svc -o wide\n</code></pre> </li> </ol>"},{"location":"traffic-shifting-gwapi/#httproutes","title":"HttpRoutes","text":"<p>Armed with two distinct destinations, the <code>HttpRoute</code> custom resource allows us to define a routing rule that sends all traffic to the <code>customers-v1</code> Service.</p> customers-route.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: customers\nspec:\n  parentRefs:\n  - group: \"\"\n    kind: Service\n    name: customers\n  rules:\n  - backendRefs:\n    - name: customers-v1\n      port: 80\n</code></pre> <p>Above, note how the targeted \"backend ref\" is the service <code>customers-v1</code>.</p> <ol> <li> <p>Apply the HttpRoute to the cluster.</p> </li> <li> <p>Verify that it's been applied.</p> <pre><code>kubectl get httproute\n</code></pre> </li> </ol>"},{"location":"traffic-shifting-gwapi/#finally-deploy-customers-v2","title":"Finally deploy customers, v2","text":"<p>Apply the following Kubernetes deployment to the cluster.</p> customers-v2.yaml <pre><code>---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: customers-v2\n  labels:\n    app: customers\n    version: v2\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: customers\n      version: v2\n  template:\n    metadata:\n      labels:\n        app: customers\n        version: v2\n    spec:\n      serviceAccountName: customers\n      containers:\n        - image: gcr.io/tetratelabs/customers:2.0.0\n          imagePullPolicy: Always\n          name: svc\n          ports:\n            - containerPort: 3000\n</code></pre>"},{"location":"traffic-shifting-gwapi/#check-that-traffic-routes-strictly-to-v1","title":"Check that traffic routes strictly to v1","text":"<ol> <li> <p>Generate some traffic.</p> <pre><code>while true; do curl -I http://$GATEWAY_IP/; sleep 0.5; done\n</code></pre> </li> <li> <p>Open a separate terminal and launch the Kiali dashboard</p> <pre><code>istioctl dashboard kiali\n</code></pre> </li> </ol> <p>Take a look at the graph, and select the <code>default</code> namespace.</p> <p>The graph should show all traffic going to v1.</p>"},{"location":"traffic-shifting-gwapi/#route-to-customers-v2","title":"Route to customers, v2","text":"<p>We wish to proceed with caution.  Before customers can see version 2, we want to make sure that the service functions properly.</p>"},{"location":"traffic-shifting-gwapi/#expose-debug-traffic-to-v2","title":"Expose \"debug\" traffic to v2","text":"<p>Review this proposed updated routing specification.</p> customers-route-debug.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: customers\nspec:\n  parentRefs:\n  - group: \"\"\n    kind: Service\n    name: customers\n  rules:\n  - matches:\n    - headers:\n      - type: Exact\n        name: user-agent\n        value: debug\n    backendRefs:\n    - name: customers-v2\n      port: 80\n  - backendRefs:\n    - name: customers-v1\n      port: 80\n</code></pre> <p>We are telling Istio to check an HTTP header:  if the <code>user-agent</code> is set to <code>debug</code>, route to v2, otherwise route to v1.</p> <p>Open a new terminal and apply the above resource to the cluster; it will overwrite the currently defined VirtualService as both yaml files use the same resource name.</p> <pre><code>kubectl apply -f customers-route-debug.yaml\n</code></pre>"},{"location":"traffic-shifting-gwapi/#test-it","title":"Test it","text":"<p>Open a browser and visit the application.</p> If you need it <pre><code>GATEWAY_IP=$(kubectl get svc -n istio-system istio-ingressgateway -ojsonpath='{.status.loadBalancer.ingress[0].ip}')\n</code></pre> <p>We can tell v1 and v2 apart in that v2 displays not only customer names but also their city (in two columns).</p> <p>The <code>user-agent</code> header can be included in a request in a number of ways:</p> Developer Tools<code>curl</code>Using a custom browser extension <p>If you're using Chrome or Firefox, you can customize the <code>user-agent</code> header as follows:</p> <ol> <li>Open the browser's developer tools</li> <li>Open the \"three dots\" menu, and select More tools \u2192 Network conditions</li> <li>The network conditions panel will open</li> <li>Under User agent, uncheck Use browser default</li> <li>Select Custom... and in the text field enter <code>debug</code></li> </ol> <p>Refresh the page; traffic should be directed to v2.</p> <pre><code>curl -H \"user-agent: debug\" http://$GATEWAY_IP\n</code></pre> <p>Check out modheader, a convenient browser extension for modifying HTTP headers in-browser.</p> <p>Tip</p> <p>If you refresh the page a good dozen times and then wait ~15-30 seconds, you should see some of that v2 traffic appear in Kiali.</p>"},{"location":"traffic-shifting-gwapi/#canary","title":"Canary","text":"<p>Well, v2 looks good; we decide to expose the new version to the public, but we're still prudent.</p> <p>Start by siphoning 10% of traffic over to v2.</p> customers-route-canary.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: customers\nspec:\n  parentRefs:\n  - group: \"\"\n    kind: Service\n    name: customers\n  rules:\n  - backendRefs:\n    - name: customers-v2\n      port: 80\n      weight: 10\n    - name: customers-v1\n      port: 80\n      weight: 90\n</code></pre> <p>Above, note the <code>weight</code> field specifying 10 percent of traffic to subset <code>v2</code>. Kiali should now show traffic going to both v1 and v2.</p> <ul> <li>Apply the above resource.</li> <li>In your browser:  undo the injection of the <code>user-agent</code> header, and refresh the page a bunch of times.</li> </ul> <p>In Kiali, under the Display pulldown menu, you can turn on traffic distribution, to see how much traffic is sent to each subset.</p> <p>Most of the requests still go to v1, but some (10%) are directed to v2.</p>"},{"location":"traffic-shifting-gwapi/#check-grafana","title":"Check Grafana","text":"<p>Before we open the floodgates, we wish to determine how v2 is faring.</p> <pre><code>istioctl dashboard grafana\n</code></pre> <p>In Grafana, visit the Istio Workload Dashboard and specifically look at the customers v2 workload. Look at the request rate and the incoming success rate, also the latencies.</p> <p>If all looks good, up the percentage from 90/10 to, say 50/50.</p> <p>Watch the request volume change (you may need to click on the \"refresh dashboard\" button in the upper right-hand corner).</p> <p>Finally, switch all traffic over to v2.</p> customers-route-final.yaml<pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: customers\nspec:\n  parentRefs:\n  - group: \"\"\n    kind: Service\n    name: customers\n  rules:\n  - backendRefs:\n    - name: customers-v2\n      port: 80\n</code></pre> <p>After you apply the above yaml, go to your browser and make sure all requests land on v2 (2-column output). Within a minute or so, the Kiali dashboard should also reflect the fact that all traffic is going to the customers v2 service.</p> <p>Though it no longer receives any traffic, we decide to leave v1 running a while longer before retiring it.</p>"},{"location":"traffic-shifting-gwapi/#going-further","title":"Going further","text":"<p>Investigate Flagger, an Istio-compatible tool that can be used to automate the process of progressive delivery (aka Canary rollouts).  Here is an exploration of Flagger with Istio and its <code>bookinfo</code> sample application.</p>"},{"location":"traffic-shifting-gwapi/#cleanup","title":"Cleanup","text":"<p>After completing this lab, reset your application to its initial state:</p> <ol> <li> <p>Delete the <code>customers</code> virtual service:</p> <pre><code>kubectl delete httproute customers\n</code></pre> </li> <li> <p>Delete the destination rule for the customers service:</p> <pre><code>kubectl delete service customers-v1\nkubectl delete service customers-v2\n</code></pre> </li> <li> <p>Delete the <code>customer-v2</code> deployment:</p> <pre><code>kubectl delete deploy customers-v2\n</code></pre> </li> </ol>"},{"location":"traffic-shifting/","title":"Traffic shifting","text":"<p>Version 2 of the customers service has been developed, and it's time to deploy it to production. Whereas version 1 returned a list of customer names, version 2 also includes each customer's city.</p>"},{"location":"traffic-shifting/#deploying-customers-v2","title":"Deploying customers, v2","text":"<p>We wish to deploy the new service but aren't yet ready to direct traffic to it.</p> <p>It would be prudent to separate the task of deploying the new service from the task of directing traffic to it.</p>"},{"location":"traffic-shifting/#labels","title":"Labels","text":"<p>The customers service is labeled with <code>app=customers</code>.</p> <p>Verify this with:</p> <pre><code>kubectl get pod -Lapp,version\n</code></pre> <p>Note the selector on the <code>customers</code> service in the output to the following command:</p> <pre><code>kubectl get svc customers -o wide\n</code></pre> <p>If we were to just deploy v2, the selector would match both versions.</p>"},{"location":"traffic-shifting/#destinationrules","title":"DestinationRules","text":"<p>We can inform Istio that two distinct subsets of the <code>customers</code> service exist, and we can use the <code>version</code> label as the discriminator.</p> customers-destinationrule.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: customers\nspec:\n  host: customers.default.svc.cluster.local\n  subsets:\n    - name: v1\n      labels:\n        version: v1\n    - name: v2\n      labels:\n        version: v2\n</code></pre> <ol> <li> <p>Apply the above destination rule to the cluster.</p> </li> <li> <p>Verify that it's been applied.</p> <pre><code>kubectl get destinationrule\n</code></pre> </li> </ol> <p>It's also worthwhile to invoke the <code>istioctl x describe</code> command on the <code>customers</code> service:</p> <pre><code>istioctl x describe svc customers\n</code></pre> <p>Notice how the output references the newly-created subsets v1 and v2.</p>"},{"location":"traffic-shifting/#virtualservices","title":"VirtualServices","text":"<p>Armed with two distinct destinations, the <code>VirtualService</code> Custom Resource allows us to define a routing rule that sends all traffic to the v1 subset.</p> customers-virtualservice.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: customers\nspec:\n  hosts:\n  - customers.default.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: customers.default.svc.cluster.local\n        subset: v1\n</code></pre> <p>Above, note how the route specifies subset v1.</p> <ol> <li> <p>Apply the virtual service to the cluster.</p> </li> <li> <p>Verify that it's been applied.</p> <pre><code>kubectl get virtualservice \n</code></pre> </li> </ol> <p>We can now safely proceed to deploy v2, without having to worry about the new workload receiving traffic.</p>"},{"location":"traffic-shifting/#finally-deploy-customers-v2","title":"Finally deploy customers, v2","text":"<p>Apply the following Kubernetes deployment to the cluster.</p> customers-v2.yaml <pre><code>---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: customers-v2\n  labels:\n    app: customers\n    version: v2\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: customers\n      version: v2\n  template:\n    metadata:\n      labels:\n        app: customers\n        version: v2\n    spec:\n      serviceAccountName: customers\n      containers:\n        - image: gcr.io/tetratelabs/customers:2.0.0\n          imagePullPolicy: Always\n          name: svc\n          ports:\n            - containerPort: 3000\n</code></pre>"},{"location":"traffic-shifting/#check-that-traffic-routes-strictly-to-v1","title":"Check that traffic routes strictly to v1","text":"<ol> <li> <p>Generate some traffic.</p> <pre><code>while true; do curl -I http://$GATEWAY_IP/; sleep 0.5; done\n</code></pre> </li> <li> <p>Open a separate terminal and launch the Kiali dashboard</p> <pre><code>istioctl dashboard kiali\n</code></pre> </li> </ol> <p>Take a look at the graph, and select the <code>default</code> namespace.</p> <p>The graph should show all traffic going to v1.</p>"},{"location":"traffic-shifting/#route-to-customers-v2","title":"Route to customers, v2","text":"<p>We wish to proceed with caution.  Before customers can see version 2, we want to make sure that the service functions properly.</p>"},{"location":"traffic-shifting/#expose-debug-traffic-to-v2","title":"Expose \"debug\" traffic to v2","text":"<p>Review this proposed updated routing specification.</p> customers-vs-debug.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: customers\nspec:\n  hosts:\n  - customers.default.svc.cluster.local\n  http:\n  - match:\n    - headers:\n        user-agent:\n          exact: debug\n    route:\n    - destination:\n        host: customers.default.svc.cluster.local\n        subset: v2\n  - route:\n    - destination:\n        host: customers.default.svc.cluster.local\n        subset: v1\n</code></pre> <p>We are telling Istio to check an HTTP header:  if the <code>user-agent</code> is set to <code>debug</code>, route to v2, otherwise route to v1.</p> <p>Open a new terminal and apply the above resource to the cluster; it will overwrite the currently defined VirtualService as both yaml files use the same resource name.</p> <pre><code>kubectl apply -f customers-vs-debug.yaml\n</code></pre>"},{"location":"traffic-shifting/#test-it","title":"Test it","text":"<p>Open a browser and visit the application.</p> If you need it <pre><code>GATEWAY_IP=$(kubectl get svc -n istio-system istio-ingressgateway -ojsonpath='{.status.loadBalancer.ingress[0].ip}')\n</code></pre> <p>We can tell v1 and v2 apart in that v2 displays not only customer names but also their city (in two columns).</p> <p>The <code>user-agent</code> header can be included in a request in a number of ways:</p> Developer Tools<code>curl</code>Using a custom browser extension <p>If you're using Chrome or Firefox, you can customize the <code>user-agent</code> header as follows:</p> <ol> <li>Open the browser's developer tools</li> <li>Open the \"three dots\" menu, and select More tools \u2192 Network conditions</li> <li>The network conditions panel will open</li> <li>Under User agent, uncheck Use browser default</li> <li>Select Custom... and in the text field enter <code>debug</code></li> </ol> <p>Refresh the page; traffic should be directed to v2.</p> <pre><code>curl -H \"user-agent: debug\" http://$GATEWAY_IP\n</code></pre> <p>Check out modheader, a convenient browser extension for modifying HTTP headers in-browser.</p> <p>Tip</p> <p>If you refresh the page a good dozen times and then wait ~15-30 seconds, you should see some of that v2 traffic appear in Kiali.</p>"},{"location":"traffic-shifting/#canary","title":"Canary","text":"<p>Well, v2 looks good; we decide to expose the new version to the public, but we're still prudent.</p> <p>Start by siphoning 10% of traffic over to v2.</p> customers-vs-canary.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: customers\nspec:\n  hosts:\n  - customers.default.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: customers.default.svc.cluster.local\n        subset: v2\n      weight: 10\n    - destination:\n        host: customers.default.svc.cluster.local\n        subset: v1\n      weight: 90\n</code></pre> <p>Above, note the <code>weight</code> field specifying 10 percent of traffic to subset <code>v2</code>. Kiali should now show traffic going to both v1 and v2.</p> <ul> <li>Apply the above resource.</li> <li>In your browser:  undo the injection of the <code>user-agent</code> header, and refresh the page a bunch of times.</li> </ul> <p>In Kiali, under the Display pulldown menu, you can turn on \"Traffic Distribution\", to view the relative percentage of traffic sent to each subset.</p> <p>Most of the requests still go to v1, but some (10%) are directed to v2.</p>"},{"location":"traffic-shifting/#check-grafana","title":"Check Grafana","text":"<p>Before we open the floodgates, we wish to determine how v2 is faring.</p> <pre><code>istioctl dashboard grafana\n</code></pre> <p>In Grafana, visit the Istio Workload Dashboard and specifically look at the customers v2 workload. Look at the request rate and the incoming success rate, also the latencies.</p> <p>If all looks good, up the percentage from 90/10 to, say 50/50.</p> <p>Watch the request volume change (you may need to click on the \"refresh dashboard\" button in the upper right-hand corner).</p> <p>Finally, switch all traffic over to v2.</p> customers-virtualservice-final.yaml<pre><code>---\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: customers\nspec:\n  hosts:\n  - customers.default.svc.cluster.local\n  http:\n  - route:\n    - destination:\n        host: customers.default.svc.cluster.local\n        subset: v2\n</code></pre> <p>After applying the above resource, go to your browser and make sure all requests land on v2 (two-column output). Within a minute or so, the Kiali dashboard should also reflect the fact that all traffic is going to the customers v2 service.</p> <p>Though it no longer receives any traffic, we decide to leave v1 running a while longer before retiring it.</p>"},{"location":"traffic-shifting/#going-further","title":"Going further","text":"<p>Investigate Flagger, an Istio-compatible tool that can be used to automate the process of progressive delivery (aka Canary rollouts).  Here is an exploration of Flagger with Istio and its <code>bookinfo</code> sample application.</p>"},{"location":"traffic-shifting/#cleanup","title":"Cleanup","text":"<p>After completing this lab, reset your application to its initial state:</p> <ol> <li> <p>Delete the <code>customers</code> virtual service:</p> <pre><code>kubectl delete virtualservice customers\n</code></pre> </li> <li> <p>Delete the destination rule for the customers service:</p> <pre><code>kubectl delete destinationrule customers\n</code></pre> </li> <li> <p>Delete the <code>customer-v2</code> deployment:</p> <pre><code>kubectl delete deploy customers-v2\n</code></pre> </li> </ol>"}]}